#!/bin/bash
#=
julia --project="$(realpath "$(dirname "${BASH_SOURCE[0]}")")" -e 'using Pkg; Pkg.instantiate()'
exec julia --project="$(realpath "$(dirname "${BASH_SOURCE[0]}")")" "${BASH_SOURCE[0]}" "$@"
=#
# Interconverts FASTA and FASTQ files, optionally interleaving and/or deinterleaving reads

# Import packages
using ArgParse
using CodecZlib
using FASTX
using TranscodingStreams

# Setup the argument table
argsettings = ArgParseSettings()
@add_arg_table argsettings begin
    "--in","-i"
        help     = "file(s) to be converted"
        required = true
        arg_type = String
        nargs    = 1
    "--in2","-n"
        help     = "second file to be interleaved"
        arg_type = String
        nargs    = 1
    "--out","-o"
        help     = "file(s) to write to"
        required = true
        arg_type = String
        nargs    = 1
    "--interleave"
        help     = "combine paired read files into a single file"
        action   = :store_true
    "--deinterleave"
        help     = "separate paired reads into separate files"
        action   = :store_true
end
args = parse_args(argsettings)

# Split the arguments into individual variables
inputfile    = join.(strip.(args["in"]))
inputfile2   = join.(strip.(args["in2"]))
outputfile   = join.(strip.(args["out"]))
interleave   = args["interleave"]
deinterleave = args["deinterleave"]

# Check that we haven't been asked to both combine and separate
if interleave && deinterleave
    println("--interleave and --deinterleave cannot be used together")
    exit(1)
end

# Check that we have two input files if interleaving
if interleave && length(inputfile2) < 1
    println("two input files must be provided when using --interleave")
    exit(1)
end

# Check that we have two output files if deinterleaving
if deinterleave && length(outputfile) != 2
    println("two output files must be provided when using --deinterleave")
    exit(1)
end

# Combine the input file arguments if we are interleaving
if interleave
    inputfile = [inputfile[1], inputfile2[1]]
end

function reader(filename, type, stream)
    if type == "fasta"
        return FASTA.Reader(stream(open(filename, "r")))
    elseif type == "fastq"
        return FASTQ.Reader(stream(open(filename, "r")))
    else
        println("unrecognized input file extension ", type)
        exit(1)
    end
end

function writer(filename, type, stream)
    if type == "fasta"
        return FASTA.Writer(stream(open(filename, "w")))
    elseif type == "fastq"
        return FASTQ.Writer(stream(open(filename, "w")))
    else
        println("unrecognized output file extension ", type)
        exit(1)
    end
end

function stream(filename, direction)
    # Parse the proper extension
    extension = join(split(filename, ".")[end])

    # Check for gzipped file
    if extension == "gz"
        # Extract the meaningful extension
        extension = join(split(filename, ".")[end-1])

        # Get a gzipped stream pointing in the right direction
        if direction == :input
            streamtype = GzipDecompressorStream
        elseif direction == :output
            streamtype = GzipCompressorStream
        else
            throw(ArgumentError("Valid values for 'direction' are :input and :output"))
        end
    else
        # No compression, stream direction is irrelevant
        streamtype = NoopStream
    end

    # Elongate any shortened extensions
    extension = (extension == "fa") ? "fasta" : extension
    extension = (extension == "fq") ? "fastq" : extension

    # Check if we support this extension
    if extension != "fastq" && extension != "fasta"
        println("unrecognized file extension ", extension)
        exit(1)
    end

    return streamtype, extension
end

function convertx(record, intype, outtype)
    seq  = sequence(record)
    desc = description(record)
    id   = identifier(record)
    qual = (intype == "fastq") ? quality(record) : ones(length(sequence(record)))
    if outtype == "fastq"
        newrecord = FASTQ.Record(id, desc, seq, qual)
    elseif outtype == "fasta"
        newrecord = FASTA.Record(id, desc, seq)
    else
        throw(ArgumentError(string("Unknown file type ", outtype)))
    end
end

function main(inputfile, outputfile, interleave, deinterleave)
    # Get streams and extensions
    inputstreams  = stream.(inputfile, :input)
    outputstreams = stream.(outputfile, :output)
    inputtype  = inputstreams[1][2]
    outputtype = outputstreams[1][2]

    # Launch io
    inputreader  = reader(inputfile[1], inputtype, inputstreams[1][1])
    outputwriter = writer(outputfile[1], outputtype, outputstreams[1][1])
    if interleave
        inputreader2 = reader(inputfile[2], inputtype, inputstreams[2][1])
    end
    if deinterleave
        outputwriter2 = writer(outputfile[2], outputtype, outputstreams[2][1])
    end

    # Start copying the records
    while !eof(inputreader)
        oldrecord = read(inputreader)
        newrecord = convertx(oldrecord, inputtype, outputtype)
        write(outputwriter, newrecord)
        if interleave
            oldrecord2 = read(inputreader2)
            newrecord2 = convertx(oldrecord2, inputtype, outputtype)
            write(outputwriter, newrecord2)
        end
        if deinterleave
            oldrecord = read(inputreader)
            newrecord = convertx(oldrecord, inputtype, outputtype)
            write(outputwriter2, newrecord)
        end
    end

    # Close the files
    close(inputreader)
    close(outputwriter)
    if interleave
        close(inputreader2)
    end
    if deinterleave
        close(outputwriter2)
    end
end

main(inputfile, outputfile, interleave, deinterleave)
